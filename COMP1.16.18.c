#pragma config(Sensor, in1,    secondLift,     sensorPotentiometer)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  lDrive,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rDrive,         sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  coneDetector,   sensorSONAR_cm)
#pragma config(Motor,  port1,           leftMobileIntake, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightFourBar,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           topLeftLift,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           bottomLeftLift, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           bottomRightLift, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           topRightLift,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftFourBar,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftDrive,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightMobileIntake, tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
#define fourBarUp 1300;
#define fourBarDown 2200;
#define liftUp 800;
#define liftDown 2700;
int secondStageTarget = 2200;
int liftTarget = 3000;
int taskWait = 25;
bool liftPidEnabled = true;

void pre_auton()
{
	bStopTasksBetweenModes = true;
}


task autonomous()
{

	AutonomousCodePlaceholderForTesting();
}
task secondLiftPID(){
	float kp = 0.1;
	float sum = 0;
	float error;
	while(true){
		error = secondStageTarget - SensorValue[secondLift];
		if(sum > 127){
			sum = 127;
		}
		else if(sum < -127){
			sum = -127
		}
		motor[rightFourBar] = ((error * kp) * -1;
		motor[leftFourBar] = ((error * kp) * -1;
	}
	wait1Msec(taskWait);
}

task liftPID(){
	float kp = 0.13;
	float error;
	while(liftPidEnabled){
		error = liftTarget - SensorValue[liftPot];
		motor[topLeftLift] = error * kp * -1;
		motor[topRightLift] = error * kp * -1;
		motor[bottomLeftLift] = error * kp * -1;
		motor[bottomRightLift] = error * kp * -1;
	}
	wait1Msec(taskWait);
}
task liftDriverControl(){
	while(true){
		if(vexRT[Btn5U]){
			liftPidEnabled = false;
			motor[topLeftLift] = 60;
			motor[topRightLift] = 60;
			motor[bottomLeftLift] = 60;
			motor[bottomRightLift] = 60;
		}else if(vexRT[Btn5D]){
			liftPidEnabled = false;
			motor[topLeftLift] = -127;
			motor[topRightLift] = -127;
			motor[bottomLeftLift] = -127;
			motor[bottomRightLift] = -127;
		}
		else{
			liftPidEnabled = true;
			motor[topLeftLift] = 0;
			motor[topRightLift] = 0;
			motor[bottomLeftLift] = 0;
			motor[bottomRightLift] = 0;

		}
		wait1Msec(taskWait);
	}

}
void fwdTicks(int target){
	int makeNeg = 1;
	if(target < 0){
		makeNeg = -1;
	}
	SensorValue[lDrive] = 0;
	SensorValue[rDrive] = 0;
	while((((SensorValue[lDrive] + SensorValue[rDrive]) / 2)*makeNeg) < (target*makeNeg)){
		motor[leftDrive] = 100 * makeNeg;
		motor[rightDrive] = 100 * makeNeg;
	}
	motor[leftDrive] = -60 * makeNeg;
	motor[rightDrive] = -60 * makeNeg;
	wait1Msec(50);
	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
	playTone(2048, 10);

}
void swingRight(int target){
	SensorValue[rDrive] = 0;
	while(((SensorValue[rDrive]) / 2) < target){
		motor[rightDrive] = 100;
	}
	motor[rightDrive] = -60;
	wait1Msec(50);
	motor[rightDrive] = 0;
	playTone(2048, 10);
}
void swingLeft(int target){
	SensorValue[lDrive] = 0;
	while(((SensorValue[lDrive]) / 2) < target){
		motor[leftDrive] = 100;
	}
	motor[leftDrive] = -60;
	wait1Msec(50);
	motor[leftDrive] = 0;
	playTone(2048, 10);
}
void gyroTurn(float target){
	target = target * 10;
	SensorValue[Gyro] = 0;
	int error = target - SensorValue[Gyro];
	float kp = 1.0;
	clearTimer(T1);
	clearTimer(T2);
	while((time1[T1] <= 1000) && (time1[T2] <= 5000)){
		error = target - SensorValue[Gyro];
		if(abs(error) >= 5){
			clearTimer(T1);
		}
		motor[leftDrive] = error * kp * -1;
		motor[rightDrive] = error * kp;
	}
	motor[leftDrive] = 0;
	motor[rightDrive] = 0;
	playTone(2048, 10);
}
void mobileGoalDown(){
	motor[rightMobileIntake]=127;
	motor[leftMobileIntake]=127;
}
void mobileGoalUp(){
	motor[rightMobileIntake]=-127;
	motor[leftMobileIntake]=-127;
	wait1Msec(1000);
	motor[rightMobileIntake]=0;
	motor[leftMobileIntake]=0;

}
int lastGoodValue;
int cleanUltrasonic(int input){
	if(input <= 0){
		return lastGoodValue;
	}
	else{
		lastGoodValue = input;
		return input;
	}
}
void programmingSkills(){
	liftTarget = 2000;
	fwdTicks(800);
	mobileGoalDown();
	fwdTicks(550);
	mobileGoalUp();
	fwdTicks(-1100);
	wait1Msec(500);
	gyroTurn(100.0);
	wait1Msec(250);
	fwdTicks(350);
	wait1Msec(250);
	gyroTurn(90.0);
	fwdTicks(950);
	mobileGoalDown();
	wait1Msec(250);
	mobileGoalUp();
	fwdTicks(-900);
	gyroTurn(-90.0);
	wait1Msec(250);
	fwdTicks(400);
	gyroTurn(-90.0);
	wait1Msec(250);
	fwdTicks(-400);
	fwdTicks(800);
	mobileGoalDown();
	fwdTicks(550);.
	mobileGoalUp();
	fwdTicks(-1100);

}
task usercontrol()
{
	//startTask(secondLiftPID);
	//startTask(liftPID);
	//startTask(liftDriverControl);
	//secondStageTarget = fourBarUp;

	programmingSkills();

	while (true)
	{
		if(vexRT[Btn6D]){
			motor[rightMobileIntake]=127;
			motor[leftMobileIntake]=127;
			}else if(vexRT[Btn6U]){
			motor[rightMobileIntake]=-127;
			motor[leftMobileIntake]=-127;
			}else{
			motor[rightMobileIntake]=0;
			motor[leftMobileIntake]=0;
		}
		motor[leftDrive]=vexRT[Ch1] + vexRT[Ch3];//drive control
		motor[rightDrive]=vexRT[Ch3] - vexRT[Ch1];
	}
}
